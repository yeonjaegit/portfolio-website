# 📝 포트폴리오 정리 가이드

> 노션 포트폴리오를 "내가 구현한 것" 중심으로 정리하기 위한 체크리스트

---

## 🎯 전체 방향성 (선생님 피드백)

### ✅ 유지할 것
- ERD, 아키텍처 다이어그램 (본인이 설계한 것)
- Core Engineering Decisions (본인의 기술적 의사결정)
- 본인이 직접 구현한 코드와 해결한 문제

### ❌ 삭제할 것
- **전체 API 문서** (README에 있을 내용)
- **팀 전체 기능 설명** (핵심 기능 미리보기 같은 것)
- **"80+ API", "37개 테이블"** 같은 전체 프로젝트 규모 표현

### ➕ 추가할 것
- **Coffee Shop 프로젝트** (1차 프로젝트)

---

## 📄 1. 메인 페이지 수정

> **핵심**: 메인 페이지도 "내가 구현한 것"만 표현. 
> 프로젝트 전체 기능이 아닌 **본인의 백엔드 기여**만 명시.

### ✅ 유지 (변경 없음)
- 자기소개
- 기술 스택
- GitHub Repositories 링크
- **"포트폴리오 구성" 섹션** (백엔드 개발 역할 설명이므로 OK)

### ✏️ 수정 필요

#### 1. Bros 프로젝트 "핵심" 부분

**❌ 현재 (프로젝트 전체 기능)**
```markdown
**핵심**: 소셜 기능 + 지도 기반 안전 경로 추천 서비스
```

**✅ 수정안 (본인 백엔드 기여)**
```markdown
**핵심**: Flask 기반 SNS 백엔드 (ERD 37개 테이블, API 개발, OAuth 인증)
```

#### 2. Smart Factory 프로젝트 "핵심" 부분

**❌ 현재 (프로젝트 전체 기능)**
```markdown
**핵심**: 근태 관리 자동화 + IoT 센서 기반 품질 검사
```

**✅ 수정안 (본인 백엔드 기여)**
```markdown
**핵심**: MQTT 기반 IoT 데이터 수집 + Spring Scheduler 근태 자동화 + WebSocket 실시간 모니터링
```

#### 3. "핵심 역량" 페이지 설명

**❌ 현재 (팀 전체 규모)**
```markdown
- ERD 설계 (37+ 테이블) 및 API 설계 (80+ 엔드포인트)
```

**✅ 수정안 (본인 기여만)**
```markdown
- ERD 설계 (37개 테이블, 정규화 및 관계 매핑)
- Flask Blueprint 구조 설계 및 API 개발
```

### ➕ 추가: Coffee Shop 프로젝트 (제일 위에 배치)

```markdown
## ☕ Project 1: Coffee Shop - 커피 전문 쇼핑몰

[Project 1: Coffee Shop](링크)

**기간**: 2025.09 (1차 프로젝트)  
**역할**: Spring Entity/Service/Repository/Controller 구현, React 공지사항 페이지 개발

### 📸 핵심 기능 미리보기
[필요시 스크린샷 추가]

**담당 역할**
- Product, Cart, Purchase, Member 도메인 백엔드 로직 구현
- JPA Entity 설계 및 @OneToMany, @ManyToOne 연관관계 매핑
- React 공지사항 CRUD 페이지 개발 (작성/수정/삭제/조회)
- JWT 인증 및 OAuth2(Google, Kakao) 소셜 로그인 통합

**성과**
- Monorepo 구조에서 프론트엔드-백엔드 통합 관리 경험
- JPA 기반 엔티티 설계 및 연관관계 매핑 학습
- Redux Toolkit으로 클라이언트 상태 관리 체계화

**기술 스택**: Spring Boot, Java, JPA, React, Redux Toolkit, MySQL

**👉 상세 내용 보기**: 위 하위 페이지 클릭
```

---

## 📄 2. Bros 프로젝트 페이지 (2차) 수정

> **핵심**: 이 페이지는 "내가 구현한 것" 위주로 작성. 
> 프로젝트 전체 소개는 최소화하고 본인 기여에 집중.

### ❌ 완전 삭제할 섹션

#### 1. 전체 API 문서 (거대한 테이블들)
```markdown
📡 서비스 기본 주소 (Base URL)
...
🔑 인증 및 보안 관리
| 방식 | 엔드포인트 | 설명 |
...
```
**이유**: 
- 팀 전체 프로젝트의 전체 API 목록 (본인 기여만 강조해야 함)
- 80개 엔드포인트는 팀원들과 함께 만든 전체 규모
- 포트폴리오는 본인이 구현한 API만 명시
- **참고**: README에도 전체 API 문서는 없음 (노션에만 있던 내용)

### ✅ 유지 가능 (프로젝트 소개용)
- ERD 다이어그램
- 시스템 아키텍처 다이어그램
- 시연 영상
- 간단한 기술 스택 설명

### ⚠️ 조건부 유지
**"주요 성과"의 전체 규모 표현**
```markdown
**주요 성과**
- 80+ REST API 엔드포인트 설계 및 구현  ← 애매함 (팀 전체 규모)
- 37개 테이블 정규화 설계 및 관계 매핑  ← OK (본인이 설계함)
```

**→ 해결책**: "주요 성과"를 **"프로젝트 개요"**(전체) + **"내가 구현한 것"**(본인)으로 분리

### ✏️ 수정할 섹션

#### "역할" 명확히 하기
**❌ 현재**
```markdown
**역할**: 백엔드(최연재)
```

**✅ 수정안**
```markdown
**역할**: ERD 설계, Flask Blueprint 14개 구조 설계, API 문서 작성, 
         DB 연결, JWT + OAuth 인증, 게시물/피드/멘션 API 개발
```

#### Core Engineering Decisions → "핵심 구현"
**✏️ 섹션명 변경**
```markdown
## ⚡ 핵심 구현: 피드 성능 최적화

**✅ 문제 상황**
SNS 피드 조회 시 JOIN 쿼리로 인한 500ms 지연 발생

**✅ 내가 선택한 해결책**
Write-Heavy(Fan-Out) 전략 - 게시물 작성 시 팔로워 피드에 미리 레코드 생성

**✅ 구현 코드**
[기존 Python 코드 유지]

**✅ 결과**
- 피드 조회 50ms로 단축 (10배 향상)
- 복잡한 JOIN 제거로 시스템 안정성 확보
```

#### "주요 성과" → "내가 구현한 것"

**✅ 수정안**
```markdown
## 📊 내가 구현한 것

### 백엔드 설계 및 구현
- **ERD 설계**: 37개 테이블, 1:N, N:M 관계 정의 및 외래키 제약 설정
- **Flask Blueprint 구조**: 14개 도메인 모듈 분리 및 등록
  - auth, user, post, reply, feed, route, place, cosmetic, product, payment, 
    notification, mention, search, admin
- **API 문서 작성**: 엔드포인트, 요청/응답 스펙, 에러 코드 정의
- **DB 연결**: PostgreSQL + SQLAlchemy ORM 설정 및 마이그레이션 관리

### 핵심 기능 구현
- **Write-Heavy 피드 시스템**
  - Fan-Out-On-Write 전략으로 조회 성능 500ms → 50ms (10배 향상)
  - 게시물 작성 시 팔로워 피드 테이블에 미리 레코드 생성
  
- **인증 시스템**
  - JWT 기반 Stateless 인증
  - OAuth2 소셜 로그인 (Google, Kakao, Naver) 통합
  - bcrypt 단방향 암호화로 비밀번호 보안 강화

- **게시물/피드/멘션 시스템**
  - Post, Reply, FeedItem, Mentions 테이블 설계
  - 무한 스크롤(Cursor Pagination) 구현
  - 좋아요/댓글 인터랙션 API

### 외부 API 연동
- **OSRM**: 경로 계산 API 통합 및 위험 지역 매핑
- **카카오페이**: 결제 요청/승인/취소 플로우 구현
- **OAuth 프로바이더**: Google/Kakao/Naver 소셜 로그인

### 성과
- 피드 조회 성능 10배 향상 (500ms → 50ms)
- Blueprint 모듈화로 코드 유지보수성 확보
- 트랜잭션 관리로 결제 데이터 무결성 보장
```

### ✅ 유지할 섹션
- ERD 다이어그램
- 시스템 아키텍처 다이어그램
- 인증 흐름도
- Core Engineering Decisions (Write-Heavy 전략) - 단, "내가 구현한"으로 수정
- 코드 예시

---
> **핵심**: 이 페이지도 "내가 구현한 것" 위주로 작성.

### ❌ 완전 삭제할 섹션

#### 1. 전체 API 문서
```markdown
## 🐍 플라스크 백엔드
**총 22개 (REST API 16개 + 실시간 이벤트 6개)**
...
## ☕ 스프링 부트 백엔드
**총 9개 (REST API 7개 + 실시간 메시지 2개)**
```
**이유**: 팀 전체 프로젝트 API 목록 (본인이 구현한 것만 명시)
**참고**: README에도 전체 API 문서는 없음 (노션에만 있던 내용)

### ✅ 유지 가능 (프로젝트 소개용)
- ERD 다이어그램
- 시스템 컴포넌트 다이어그램
- 데이터 흐름 시퀀스
- 시연 영상
- 멀티 서버 아키텍처 다이어그램 (간단히)

### ⚠️ 간소화 필요
**"멀티 백엔드 아키텍처" 설명**
- 현재: 테이블 비교, 장황한 설명 → 너무 길음
- 수정: "왜 선택했는지" 1-2문단으로 요약
#### 3. "멀티 백엔드 아키텍처" 장황한 설명
- 테이블 비교, 시스템 전체 구조도는 너무 길음
- 간결하게 "왜 선택했는지"만 남기기

### ✏️ 수정할 섹션

#### "역할" 명확히
**❌ 현재**
```markdown
**역할**: 백엔드 개발 총괄 (멀티 서버 아키텍처)
```

**✅ 수정안**
```markdown
**역할**: ERD 설계, Flask + Spring Boot 멀티 서버 아키텍처 설계,
         MQTT 센서 데이터 수집, AI 서버 통신, WebSocket 실시간 알림,
         JWT 인증, Spring Scheduler 자동 근태 처리
```

#### Core Engineering Decisions → "핵심 구현"

**✅ 간결하게 재작성**
```markdown
## ⚡ 핵심 구현

### 1. MQTT 기반 IoT 데이터 파이프라인

**✅ 구현 내용**
- **MQTT 클라이언트**: paho-mqtt로 센서 데이터 실시간 수집
- **AI 서버 통신**: REST API로 불량 판정 결과 연동
- **WebSocket 전파**: Flask-SocketIO로 대시보드에 즉시 브로드캐스트
- **3-Tier 검증**: MQTT → 비즈니스 로직 → DB 레벨 필터링

**✅ 핵심 코드**
```python
def on_sensor_message(client, userdata, msg):
    data = json.loads(msg.payload)
    
    # Tier 1: JSON 파싱
    # Tier 2: Whitelist 검증 (OK/DEFECT만 허용)
    if data['result'] not in ['OK', 'DEFECT']:
        return
    
    # Tier 3: DB 저장 및 실시간 전파
    sensor = SensorResult(**data)
    db.session.add(sensor)
    db.session.commit()
    socketio.emit('stats_update', calculate_stats())
```

**✅ 결과**
- 센서 데이터 수집 지연 200ms 이내
- 노이즈 데이터 차단으로 통계 정확도 향상
- 불량 감지 시 즉시 알림 전파

---

### 2. Spring Scheduler 자동 근태 처리

**✅ 구현 내용**
- **@Scheduled(cron)**: 매일 00:00:01 자동 결근 처리
- **@Transactional**: 연차 차감과 급여 계산 원자성 보장
- **WebSocket(STOMP)**: 관리자에게 실시간 알림

**✅ 핵심 코드**
```java
@Scheduled(cron = "1 0 0 * * ?")
@Transactional
public void autoAbsent() {
    // 1. 결근자 확인
    // 2. 결근 로그 생성
    // 3. WebSocket 알림 전송
    messagingTemplate.convertAndSend("/topic/attendance", notification);
}
```

**✅ 결과**
- 관리자 수작업 완전 제거 (업무 시간 90% 절감)
- 데이터 불일치 0건 (트랜잭션 보장)
- 실시간 알림 200ms 이내 전파
```

#### "주요 성과" → "내가 구현한 것"

**✅ 수정안**
```markdown
## 📊 내가 구현한 것

### 백엔드 설계 및 인프라
- **ERD 설계**: Employee, Attendance, SensorResult, CameraResult 등 테이블 구조 정의
- **멀티 서버 아키텍처**: Flask(IoT) + Spring Boot(HR) 역할 분담 및 공유 DB 전략
- **테이블 접근 권한 분리**: 도메인별 Cross-domain write 금지 규칙 수립
- **API 문서 작성**: Flask 16개, Spring Boot 7개 엔드포인트 스펙 정의

### Flask (IoT 파트) 구현
- **MQTT 클라이언트**: paho-mqtt로 센서 데이터(ULT01/02/03) 실시간 수집
- **AI 서버 통신**: 카메라 이미지 전송 및 불량 판정 결과 수신
- **WebSocket(Flask-SocketIO)**: 실시간 대시보드 데이터 스트리밍
  - `stats_update`: 통계 갱신
  - `sensor_defect`: 센서 불량 알림
  - `camera_defect`: 카메라 불량 알림
- **3-Tier 데이터 검증**: MQTT → 비즈니스 로직 → DB
  - Whitelist 방식 (OK/DEFECT만 허용)
  - 노이즈 데이터 원천 차단

### Spring Boot (HR 파트) 구현
- **JWT 기반 인증**: 직원 로그인 및 토큰 관리
- **WebSocket(STOMP)**: 실시간 채팅 서버
  - `/app/chat.sendMessage`: 메시지 전송
  - `/topic/chat/{roomId}`: 채팅방 구독
- **@Scheduled 자동 근태 처리**
  - 매일 00:00:01 결근 자동 처리
  - 18:01 퇴근 미처리자 실시간 감지
- **@Transactional 급여 계산**
  - 연차 차감과 급여 재계산 원자성 보장
  - 일급/시급 타입별 계산 로직

### 성과
- **데이터 수집**: MQTT QoS 설정으로 손실률 0%
- **자동화**: 관리자 근태 관리 업무 90% 절감
- **무결성**: 트랜잭션 관리로 데이터 불일치 0건
- **실시간성**: 알림 전파 200ms 이내
```

### ✅ 유지할 섹션
- ERD 다이어그램
- 시스템 컴포넌트 다이어그램
- 데이터 흐름 시퀀스
- 핵심 구현 코드

---

## 📄 4. Coffee Shop 프로젝트 페이지 (새로 추가)

```markdown
# ☕ FullStack Web-Project - 커피 전문 쇼핑몰

> **기간**: 2025.09 (1차 프로젝트) | **역할**: Full Stack (Spring Boot + React)

## 📋 프로젝트 개요
커피 전문 온라인 쇼핑몰 플랫폼. Spring Boot 백엔드와 React 프론트엔드를 
Monorepo로 관리하며 상품 판매부터 커뮤니티까지 제공합니다.

## 🛠️ 기술 스택
**Backend**: Spring Boot, Java, JPA, Spring Security, OAuth2, JWT, MySQL
**Frontend**: React, Redux Toolkit, Vite, Bootstrap, Axios

## 📊 내가 구현한 것

### Spring Boot (백엔드)
- **Entity 설계 및 구현**
  - Product (상품), Cart (장바구니), Purchase (주문), Member (회원)
  - @OneToMany, @ManyToOne 연관관계 매핑
  - Lazy Loading 전략으로 N+1 문제 방지
  
- **Service Layer**
  - CRUD 비즈니스 로직 구현
  - 트랜잭션 관리 및 예외 처리
  
- **Controller (REST API)**
  - @RestController로 JSON 응답
  - @RequestBody, @PathVariable 활용
  
- **인증**
  - JWT 토큰 기반 인증
  - OAuth2(Google, Kakao) 소셜 로그인

### React (프론트엔드)
- **공지사항 페이지 구현**
  - 공지사항 목록 조회 (페이지네이션)
  - 공지사항 상세보기
  - 공지사항 작성/수정/삭제 (관리자)
  - React-Quill 에디터 통합

- **Redux Toolkit**
  - 전역 상태 관리 (사용자 정보, 장바구니)
  - API 통신 로직 분리

## 🎯 학습 성과
- **Monorepo 구조**: 프론트엔드-백엔드 통합 관리 경험
- **JPA 이해도 향상**: Entity 설계 및 연관관계 매핑 학습
- **상태 관리**: Redux Toolkit으로 클라이언트 상태 체계화
- **팀 협업**: Git 브랜치 전략 및 코드 리뷰 경험

## 📦 GitHub Repository
[GitHub 🔗](https://github.com/yeonjaegit/team-test)
```

---

## 📄 5. 핵심 역량 페이지 수정

### ✅ 유지
- 문제 해결 능력 (Write-Heavy, 트랜잭션, 자동화)
- 기술적 강점 (ERD, API, 실시간 통신, 트랜잭션)
- 학습 태도
- 성장 계획

### ✏️ "기술적 강점" 수정

**❌ 현재**
```markdown
**🔌 API 설계**
- RESTful 원칙을 따르는 일관된 API 구조 **(총 80+ 엔드포인트)**
- Blueprint/Router 패턴으로 기능별 모듈 분리 **(14개 모듈)**
```

**✅ 수정안**
```markdown
**🔌 API 설계 및 문서화**
- RESTful 원칙을 따르는 일관된 엔드포인트 구조
- API 문서 작성 (엔드포인트, 요청/응답 스펙, 에러 코드 정의)
- Blueprint/Router 패턴으로 도메인별 모듈 분리
- 예외 처리 표준화로 프론트엔드 개발 효율성 향상
```

### ➕ Coffee Shop 내용 추가

```markdown
**💾 데이터베이스 설계**
- 정규화와 성능 균형을 고려한 ERD 설계
- 1:N, N:M 관계 명확히 정의 및 중간 테이블 설계
- 외래키 제약과 복합 인덱스로 데이터 무결성과 조회 성능 확보

**JPA/ORM 활용**
- JPA Entity 설계 (Product, Cart, Purchase, Member)
- @OneToMany, @ManyToOne 연관관계 매핑
- Lazy Loading 전략으로 N+1 문제 방지
```

---

## 🎯 체크리스트 - 각 프로젝트 페이지 최종 점검

### ✅ 반드시 포함
- [ ] ERD (본인이 설계한 것)
- [ ] 내가 직접 구현한 기능 목록 (구체적으로)
- [ ] 내가 해결한 문제와 접근 방식
- [ ] 핵심 구현 코드 (주석 포함)
- [ ] 구체적인 성과 (수치 포함)

### ❌ 반드시 삭제
- [ ] 전체 API 엔드포인트 목록
- [ ] 팀 전체 기능 설명
- [ ] "80개 API", "37개 테이블" 같은 전체 규모 표현
- [ ] README에 있을 상세한 기술 스택 버전

### ✏️ 수정 필요
- [ ] "역할: 백엔드 개발 총괄" → 구체적인 작업 나열
- [ ] "주요 성과" → "내가 구현한 것"
- [ ] "핵심 기능" → "내가 담당한 기능"
- [ ] "Core Engineering Decisions" → "핵심 구현"

---

## 📋 작업 우선순위

### 🔴 High Priority (먼저 작업)
1. ✅ Bros, Smart Factory에서 **API 문서 전체 삭제**
2. ✅ "주요 성과" → **"내가 구현한 것"**으로 섹션명 변경 및 내용 재작성
3. ✅ **Coffee Shop 프로젝트 추가** (메인 페이지 + 하위 페이지)

### 🟡 Medium Priority
4. ✅ Core Engineering Decisions를 **"핵심 구현"**으로 변경하고 본인 기여 중심으로 재작성
5. ✅ 메인 페이지에 각 프로젝트 **역할을 구체적으로 명시**
6. ✅ "백엔드 개발 총괄" 같은 모호한 표현 제거

### 🟢 Low Priority
7. ✅ 핵심 역량 페이지에 Coffee Shop 내용 추가
8. ✅ 전반적인 문구 다듬기 (간결하고 구체적으로)

---

## � 기능별 구현 화면 선정 가이드

### 🚗 Bros 프로젝트 - 본인이 구현한 핵심 3개

#### 1️⃣ Write-Heavy 피드 시스템 [성능 최적화] ✅ 유지

**본인 구현 내용:**
- Fan-Out-On-Write 전략 설계 및 구현
- 게시물 작성 시 팔로워 피드 테이블에 미리 삽입하는 로직
- 피드 조회 성능 500ms → 50ms (10배 향상)

**필요한 스크린샷:**
- 피드 목록 화면 (무한 스크롤)
- 게시물 작성 화면
- 좋아요/댓글 기능 동작
- 성능 비교 그래프 (있다면)

**코드 예시:** ✅ 현재 잘 작성됨
- `create_post()` - 팔로워에게 피드 전파
- `get_feed()` - 최적화된 조회
- Trade-off 분석 테이블

---

#### 2️⃣ JWT/OAuth 인증 시스템 [보안] ✅ 유지

**본인 구현 내용:**
- JWT 기반 Stateless 인증 구현
- OAuth 2.0 소셜 로그인 (Google, Kakao, Naver) 통합
- bcrypt 단방향 암호화로 비밀번호 보안

**필요한 스크린샷:**
- 로그인 화면
- 소셜 로그인 버튼 (3개 provider)
- 회원가입 화면
- 인증 흐름도 (있다면)

**코드 예시:** ✅ 현재 잘 작성됨
- `@auth_bp.route('/login')` 로직
- JWT 토큰 발급
- bcrypt 검증

---

#### 3️⃣ 팔로우/친구 관계 시스템 [소셜 네트워크] ✅ 추가

**본인 구현 내용:**
- Follow 자기참조 관계 (User ↔ Follow) 설계 및 구현
- Friend 요청/수락 시스템 (양방향 관계)
- 팔로워/팔로잉 목록 조회 API
- 친구 추천 알고리즘 (공통 친구 기반)

**필요한 스크린샷:**
- 팔로우/언팔로우 버튼
- 팔로워 목록
- 팔로잉 목록
- 친구 요청 알림
- 친구 목록 화면

**코드 예시 (작성 필요):**
```python
@follow_bp.route('/follow/<int:target_id>', methods=['POST'])
@jwt_required()
def follow_user(target_id):
    # 자기 자신 팔로우 방지
    if user_id == target_id:
        return {"error": "Cannot follow yourself"}, 400
    
    # 중복 팔로우 방지
    existing = Follow.query.filter_by(
        follower_id=user_id, 
        followed_id=target_id
    ).first()
    
    if existing:
        return {"error": "Already following"}, 400
    
    # 팔로우 관계 생성
    follow = Follow(follower_id=user_id, followed_id=target_id)
    db.session.add(follow)
    db.session.commit()
    
    # 팔로우 알림 전송 (Socket.io)
    socketio.emit('follow_notification', {
        'follower': user.name,
        'follower_id': user_id
    }, room=f'user_{target_id}')
    
    return {"success": True}, 201

@follow_bp.route('/followers', methods=['GET'])
@jwt_required()
def get_followers():
    # 나를 팔로우한 사람들
    followers = Follow.query.filter_by(followed_id=user_id).all()
    return jsonify([{
        'user_id': f.follower.id,
        'name': f.follower.name,
        'profile_image': f.follower.profile_image
    } for f in followers])
```

**ERD 관계:**
```
User (1) ---- (N) Follow (자기참조)
  - follower_id → User.id
  - followed_id → User.id
  
User (N) ---- (N) Friend (양방향)
  - user_id → User.id
  - friend_id → User.id
```

---

### 🏭 Smart Factory 프로젝트 - 본인이 구현한 핵심 3개

#### 1️⃣ MQTT 기반 IoT 실시간 모니터링 [실시간 통신] ✅ 유지

**본인 구현 내용:**
- MQTT → Flask → WebSocket 파이프라인 구축
- 센서 데이터 수신 즉시 대시보드 전파
- 불량 감지 시 200ms 이내 알림

**필요한 스크린샷:**
- 실시간 대시보드 (센서별 불량률 그래프)
- 불량 감지 알림 팝업
- MQTT 메시지 흐름도

**코드 예시:** ✅ 현재 잘 작성됨
- `on_sensor_message()` - MQTT 수신
- WebSocket emit 로직
- 3-Tier 검증

---

#### 2️⃣ Spring Scheduler 자동 결근 처리 [업무 자동화] ✅ 유지

**본인 구현 내용:**
- 매일 00:00:01 자동 배치 작업
- 연차 차감 + 급여 재계산 트랜잭션 관리
- WebSocket 실시간 알림 전송

**필요한 스크린샷:**
- 근태 관리 대시보드
- 자동 결근 처리 결과 화면
- 퇴근 미처리자 알림
- 연차/급여 변경 내역

**코드 예시:** ✅ 현재 잘 작성됨
- `@Scheduled(cron = "1 0 0 * * ?")` 로직
- `@Transactional` 처리
- Trade-off 분석 테이블

---

#### 3️⃣ 3-Tier 데이터 검증 [품질 보증] ✅ 유지

**본인 구현 내용:**
- MQTT → 비즈니스 로직 → DB 레벨 단계별 필터링
- Whitelist 방식으로 OK/DEFECT만 허용
- 비정상 데이터 유입 원천 차단

**필요한 스크린샷:**
- 센서 데이터 목록 (OK/DEFECT만 있음)
- 통계 대시보드 (정확한 불량률)
- 검증 실패 로그 (있다면)

**코드 예시:** ✅ 현재 잘 작성됨
- `save_sensor_result()` 로직
- 3단계 검증 설명

---

## ☕ Coffee Shop 프로젝트 페이지 구조

```markdown
# ☕ Coffee Shop - 커피 전문 쇼핑몰

> **기간**: 2025.09 (2주) | **역할**: Full Stack (Spring Boot + React)

<aside>
💻

**📦 Coffee Shop Repository**: [GitHub 🔗](https://github.com/yeonjaegit/team-test)

Spring Boot Entity/Service/Controller 구현, React 공지사항 페이지, JPA 연관관계 매핑이 포함되어 있습니다.

</aside>

---

## 🛠️ 기술 스택

<aside>
⚡

**Backend**: Spring Boot · JPA · Spring Security · OAuth2 · JWT · MySQL

**Frontend**: React · Redux Toolkit · Vite · Bootstrap · Axios

**Key Features**: JPA Entity 설계 · OAuth 소셜 로그인 · Monorepo 관리 · CRUD API 구현

</aside>

---

## 🏗️ 시스템 아키텍처

### 📸 ERD (있다면 추가)
[ERD 이미지]

### 📌 담당 도메인

**백엔드 (Spring Boot)**
- **Product**: 상품 관리 (커피 원두, 용품)
- **Cart**: 장바구니 (상품 추가/수정/삭제)
- **Purchase**: 주문 및 결제 처리
- **Member**: 회원 관리 및 인증

**프론트엔드 (React)**
- **공지사항 페이지**: CRUD 기능 전체 구현

---

## ⚡ Core Engineering Decisions

### 1. JPA 연관관계 매핑으로 객체 중심 설계

**✅ Challenge**
- **상황**: 장바구니-상품, 주문-회원 등 복잡한 관계 처리 필요
- **문제**: SQL JOIN 직접 작성 시 코드 가독성 저하 및 유지보수 어려움

**✅ Choice: JPA @OneToMany, @ManyToOne 활용**

**대안 1: MyBatis (SQL 직접 작성)**
- 장점: SQL 제어 자유도 높음
- 단점: 객체-테이블 매핑 수동 작성, 반복 코드 증가

**대안 2: Spring JDBC Template**
- 장점: 경량, 빠른 실행
- 단점: ORM 없음, 관계 매핑 수동 처리

**채택: JPA (Spring Data JPA)**
- @OneToMany, @ManyToOne으로 관계 자동 매핑
- JPQL로 객체 중심 쿼리 작성
- Lazy Loading으로 N+1 문제 방지

**✅ Implementation (Java)**
```java
@Entity
public class Cart {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // 다대일: 여러 장바구니 항목 → 한 명의 회원
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "member_id")
    private Member member;
    
    // 다대일: 여러 장바구니 항목 → 한 개의 상품
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id")
    private Product product;
    
    private Integer quantity;
}

@Entity
public class Purchase {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // 다대일: 여러 주문 → 한 명의 회원
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "member_id")
    private Member member;
    
    // 일대다: 한 주문 → 여러 주문 항목
    @OneToMany(mappedBy = "purchase", cascade = CascadeType.ALL)
    private List<PurchaseItem> items = new ArrayList<>();
    
    private LocalDateTime orderDate;
    private String status; // PENDING, COMPLETED, CANCELLED
}
```

**✅ Result**
- **코드 간결화**: SQL 직접 작성 대비 50% 코드 감소
- **유지보수성**: 연관관계 변경 시 Entity만 수정
- **N+1 방지**: Lazy Loading으로 불필요한 쿼리 제거

---

## 🔧 기능별 구현 화면 및 백엔드 기술

### 1️⃣ 상품 관리 시스템 (Product CRUD)

[상품 목록 화면 스크린샷]
[상품 상세 화면 스크린샷]

**✅ 구현 내용**
- Product Entity 설계 (상품명, 가격, 재고, 카테고리)
- RESTful API 구현 (GET, POST, PUT, DELETE)
- Service Layer 비즈니스 로직 (재고 관리, 가격 계산)

**✅ 핵심 로직 (Java)**
```java
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    // 상품 목록 조회 (페이징)
    public Page<Product> getProducts(Pageable pageable) {
        return productRepository.findAll(pageable);
    }
    
    // 상품 상세 조회
    public Product getProduct(Long id) {
        return productRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("상품을 찾을 수 없습니다."));
    }
    
    // 상품 등록
    @Transactional
    public Product createProduct(ProductDto dto) {
        Product product = Product.builder()
            .name(dto.getName())
            .price(dto.getPrice())
            .stock(dto.getStock())
            .build();
        return productRepository.save(product);
    }
}

@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @Autowired
    private ProductService productService;
    
    @GetMapping
    public ResponseEntity<Page<Product>> getProducts(Pageable pageable) {
        return ResponseEntity.ok(productService.getProducts(pageable));
    }
    
    @PostMapping
    public ResponseEntity<Product> createProduct(@RequestBody ProductDto dto) {
        return ResponseEntity.ok(productService.createProduct(dto));
    }
}
```

---

### 2️⃣ 장바구니 시스템 (Cart Management)

[장바구니 화면 스크린샷]

**✅ 구현 내용**
- Cart Entity 설계 (Member, Product 연관관계)
- 장바구니 추가/수정/삭제 API
- 수량 변경 및 총 금액 계산 로직

**✅ 핵심 로직 (Java)**
```java
@Service
public class CartService {
    
    @Autowired
    private CartRepository cartRepository;
    
    // 장바구니 추가
    @Transactional
    public Cart addToCart(Long memberId, Long productId, Integer quantity) {
        // 기존 항목 확인
        Optional<Cart> existing = cartRepository
            .findByMemberIdAndProductId(memberId, productId);
        
        if (existing.isPresent()) {
            // 수량 업데이트
            Cart cart = existing.get();
            cart.setQuantity(cart.getQuantity() + quantity);
            return cartRepository.save(cart);
        } else {
            // 새 항목 생성
            Cart cart = Cart.builder()
                .memberId(memberId)
                .productId(productId)
                .quantity(quantity)
                .build();
            return cartRepository.save(cart);
        }
    }
    
    // 장바구니 총 금액 계산
    public Integer calculateTotal(Long memberId) {
        List<Cart> carts = cartRepository.findByMemberId(memberId);
        return carts.stream()
            .mapToInt(cart -> cart.getProduct().getPrice() * cart.getQuantity())
            .sum();
    }
}
```

---

### 3️⃣ OAuth 소셜 로그인 (Google, Kakao)

[로그인 화면 스크린샷]
[OAuth 버튼 스크린샷]

**✅ 구현 내용**
- Spring Security + OAuth2 Client 설정
- Google, Kakao Provider 등록
- JWT 토큰 발급 및 인증 처리

**✅ 핵심 로직 (Java)**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .oauth2Login(oauth2 -> oauth2
                .userInfoEndpoint(userInfo -> userInfo
                    .userService(customOAuth2UserService)
                )
                .successHandler(oAuth2SuccessHandler)
            )
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .anyRequest().authenticated()
            );
        return http.build();
    }
}

@Service
public class CustomOAuth2UserService extends DefaultOAuth2UserService {
    
    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) {
        OAuth2User oAuth2User = super.loadUser(userRequest);
        
        String provider = userRequest.getClientRegistration().getRegistrationId();
        String email = oAuth2User.getAttribute("email");
        String name = oAuth2User.getAttribute("name");
        
        // 회원 정보 저장 또는 업데이트
        Member member = memberRepository.findByEmail(email)
            .orElseGet(() -> {
                Member newMember = Member.builder()
                    .email(email)
                    .name(name)
                    .provider(provider)
                    .build();
                return memberRepository.save(newMember);
            });
        
        return new PrincipalDetails(member, oAuth2User.getAttributes());
    }
}
```

---

### 4️⃣ React 공지사항 페이지 (Frontend)

[공지사항 목록 스크린샷]
[공지사항 작성 화면 스크린샷]

**✅ 구현 내용**
- 공지사항 목록 조회 (페이지네이션)
- 공지사항 작성/수정/삭제 (관리자)
- Redux Toolkit으로 상태 관리
- React-Quill 에디터 통합

**✅ 핵심 로직 (JavaScript)**
```javascript
// Redux Slice
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

export const fetchNotices = createAsyncThunk(
  'notice/fetchNotices',
  async (page) => {
    const response = await axios.get(`/api/notices?page=${page}`);
    return response.data;
  }
);

const noticeSlice = createSlice({
  name: 'notice',
  initialState: {
    notices: [],
    loading: false,
    error: null,
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchNotices.fulfilled, (state, action) => {
        state.notices = action.payload;
        state.loading = false;
      });
  },
});

// Component
function NoticeList() {
  const dispatch = useDispatch();
  const { notices, loading } = useSelector((state) => state.notice);
  
  useEffect(() => {
    dispatch(fetchNotices(1));
  }, [dispatch]);
  
  return (
    <div>
      {loading ? <Spinner /> : (
        <Table>
          {notices.map(notice => (
            <tr key={notice.id}>
              <td>{notice.title}</td>
              <td>{notice.createdAt}</td>
            </tr>
          ))}
        </Table>
      )}
    </div>
  );
}
```

---

## 📊 핵심 성과

### ✅ 정량적 성과
1. **JPA Entity 설계**: 4개 도메인 (Product, Cart, Purchase, Member) 연관관계 매핑
2. **RESTful API**: 15개 엔드포인트 구현 (CRUD 기본 + 비즈니스 로직)
3. **OAuth 통합**: Google, Kakao 2개 Provider 소셜 로그인 구현
4. **Monorepo 관리**: Spring Boot + React 통합 빌드 및 배포 경험

### 💡 배운 점
- **JPA 활용**: Entity 연관관계 매핑과 Lazy Loading 전략 이해
- **Spring Security**: OAuth2 Client 설정 및 JWT 토큰 관리 학습
- **전체 스택 경험**: 백엔드 API 개발 → 프론트엔드 연동까지 전 과정 체험
- **상태 관리**: Redux Toolkit으로 클라이언트 상태 체계화

### 🔧 향후 개선 과제
- **결제 연동**: 실제 PG사(토스페이먼츠 등) 연동 필요
- **재고 동시성**: 동시 주문 시 재고 감소 Lock 처리 필요
- **테스트 코드**: JUnit + Mockito로 서비스 계층 테스트 작성

---

**Last Updated**: 2026년 1월 20일
```

---

## 🏭 Smart Factory - 간소화 권장 사항

### ❌ 삭제 또는 간소화할 섹션

#### 1. Core Engineering Decisions 교체 ✅

**현재 문제:**
- "멀티 백엔드 아키텍처" 내용이 위쪽 테이블과 중복
- 이미 아키텍처 설명에서 다룸

**✅ 교체 권장: "3-Tier 데이터 검증 전략"**

```markdown
## ⚡ Core Engineering Decisions

### 1. 3-Tier 데이터 검증으로 센서 데이터 신뢰성 확보

**✅ Challenge**
- **상황**: 외부 센서(ULT01/02/03)와 AI 카메라에서 실시간 데이터 수신
- **문제**: 센서 오작동, 네트워크 노이즈, AI 오판 등으로 비정상 데이터 유입 가능
- **영향**: 불량률 통계 왜곡 → 품질 의사결정 오류 → 생산 라인 손실

**✅ Choice: MQTT → 비즈니스 로직 → DB 3단계 검증**

**대안 1: 단일 레벨 검증 (DB만)**
- 장점: 구현 간단, 코드량 최소
- 단점: 비정상 데이터가 DB까지 도달 → 롤백 필요 → 성능 저하

**대안 2: 2-Tier 검증 (비즈니스 로직 + DB)**
- 장점: 대부분 케이스 방어 가능
- 단점: MQTT 레벨 공격(악의적 메시지)은 방어 불가

**채택: 3-Tier 검증 (MQTT + 로직 + DB)**
- Tier 1 (MQTT): JSON 파싱 실패 → 즉시 차단
- Tier 2 (비즈니스 로직): Whitelist 검증 (OK/DEFECT만 허용)
- Tier 3 (DB): ENUM 제약으로 최종 방어

**✅ Implementation (Python)**
```python
# MQTT 메시지 수신 (on_message)
def on_message(client, userdata, msg):
    with _flask_app.app_context():
        try:
            payload_str = msg.payload.decode().strip()
            
            # Tier 1: JSON 파싱 검증
            try:
                data = json.loads(payload_str)
            except json.JSONDecodeError as e:
                print(f"[에러] JSON 파싱 실패: {e}")
                return  # 비정상 메시지 즉시 차단
            
            # 센서 결과 처리
            if msg.topic == TOPIC_SENSOR_RESULT:
                save_sensor_result(data)
                
        except Exception as e:
            print(f"[에러] on_message 처리 실패: {e}")

# 센서 결과 검증 및 저장 (save_sensor_result)
def save_sensor_result(data):
    device = data["device"].upper()
    result = data["result"].upper()
    
    # Tier 2: 비즈니스 로직 - Whitelist 검증
    if result in ['OK', 'DEFECT']:
        # Tier 3: DB 저장 (ENUM 제약으로 최종 방어)
        sensor = SensorResult(
            car_id=current_car_id,
            device=device,
            result=result  # DB ENUM('OK', 'DEFECT')
        )
        db.session.add(sensor)
        db.session.commit()
        
        # WebSocket 실시간 전파
        if result == "DEFECT":
            emit_sensor_defect(sensor_data)
        else:
            emit_stats_update()
    else:
        # 비정상 데이터 DB 저장 전에 차단
        print(f"[경고] {result} 상태는 DB에 저장하지 않습니다.")
```

**✅ Trade-Off 분석**

| 항목 | 단일 레벨 | 2-Tier | 3-Tier (본 프로젝트) |
|------|----------|--------|---------------------|
| **코드 복잡도** | 낮음 | 중간 | 높음 |
| **성능** | 빠름 | 중간 | 약간 느림 (검증 오버헤드) |
| **신뢰성** | 낮음 | 중간 | **높음 (100%)** |
| **DB 부하** | 높음 (롤백) | 낮음 | **최소** |
| **적합 환경** | 내부 테스트 | 일반 서비스 | **미션 크리티컬** |

**✅ Result**
- **데이터 신뢰성**: 검증 실패 데이터 DB 유입 0건
- **통계 정확도**: 노이즈 제거로 불량률 정밀 산출
- **시스템 안정성**: DB 롤백 0회 (성능 영향 최소화)
- **보안**: MQTT 레벨 공격 차단 (악의적 메시지 방어)
```

---

#### 2. 공유 DB 설명 중복 (3곳에서 설명함)
**현재 문제:**
- "공유 DB 사용 이유" (3줄)
- "리스크 대응" (3줄)  
- "왜 독립 DB가 아닌 공유 DB인가?" (4줄)

**✅ 간소화 방법:**
하나로 통합:
```markdown
### 공유 DB 전략

**선택 이유:** 
센서 데이터(Flask)와 인사 데이터(Spring Boot)의 실시간 통합 대시보드 요구사항을 위해 
데이터 동기화 지연 없는 공유 DB 채택

**리스크 관리:**
- 테이블 단위 접근 분리 (Cross-domain write 금지)
- 도메인별 트랜잭션은 각 서버에서만 관리
```

---

#### 2. 시스템 구조도 중복
**현재 문제:**
- "시스템 컴포넌트 다이어그램" (이미지) ✅
- "데이터 흐름 시퀀스" (이미지) ✅
- "시스템 전체 구조도" (ASCII 텍스트) ← ❌ **삭제**

**이유:** 이미 이미지 다이어그램 2개가 있으므로 ASCII 텍스트는 불필요

---

#### 3. Core Engineering Decisions 중복
**현재 문제:**
- 위쪽에 "Spring Boot vs Flask 역할 분담" 테이블
- Core Engineering Decisions에 또 "멀티 백엔드 아키텍처 선택" 설명

**✅ 해결책:**
- 위쪽 테이블은 **간단히 유지** (빠른 이해)
- Core Engineering Decisions는 **"왜 선택했는지" + 코드 중심**으로 작성

---

#### 4. "기술적 도전과 학습" 섹션
**현재:**
```markdown
## 💡 기술적 도전과 학습
> WebSocket 독학을 통한 실시간 근태 알림 구현
```

**✅ 통합 권장:**
이 내용을 **"배운 점"** 섹션으로 이동:
```markdown
### 💡 배운 점
- **기술 적응력**: WebSocket을 프로젝트 중 독학하여 실시간 알림 구현 (200ms 지연)
- **전략적 설계**: 도메인 특성에 따른 Spring + Flask 멀티 백엔드 구축
...
```

---

## ✅ Smart Factory 최종 구조 (간소화 후)

```markdown
1. GitHub Repository 링크
2. 시연 영상
3. 기술 스택
4. ERD
5. 멀티 서버 아키텍처 (간단히) ← 공유 DB 설명 통합
6. Spring Boot vs Flask 역할 테이블 ← 유지
7. 시스템 다이어그램 (이미지 2개만) ← ASCII 삭제
8. 아키텍처 특징 (5가지)
9. Core Engineering Decisions (코드 중심)
10. 기능별 구현 3개 (MQTT, Scheduler, 3-Tier)
11. 핵심 성과
12. 배운 점 (WebSocket 독학 통합) ← 통합
```

---

## 📊 Bros vs Smart Factory 비교

| 항목 | Bros | Smart Factory |
|------|------|---------------|
| **본인 구현만 표현** | ✅ 완벽 | ✅ 완벽 |
| **중복 설명** | ✅ 없음 | ⚠️ 공유 DB 3곳, 구조도 2개 |
| **간결성** | ✅ 깔끔 | ⚠️ 아키텍처 설명 장황 |
| **페이지 길이** | 적당 | 과다 |

---

## �💡 핵심 원칙 (선생님 피드백)

> "자기 포폴이니까 해당 플젝에서 자신이 맡은 역할과 자기가 기여한 부분만 넣으면 될듯"
### 📍 페이지별 원칙

**메인 페이지** (전체 소개)
- ✅ 프로젝트 전체 개요 가능
- ✅ "포트폴리오 구성" 설명 가능
- ✅ 핵심 기능 미리보기 (스크린샷) 가능
- ⚠️ 역할은 간단히 요약

**하위 페이지** (상세 내용)
- ✅ "내가 구현한 것" 위주로 작성
- ❌ 전체 API 문서는 삭제
- ✅ ERD, 아키텍처는 유지 (본인이 설계)
- ✅ 본인 코드와 해결한 문제 집중

### 🎯 작성 원칙

1. **전체 프로젝트 규모는 하위 페이지에서 제거**
   - ❌ "80+ API 구현" (팀 전체 규모)
   - ✅ "게시물/피드/멘션 API 개발" (본인 담당)

2. **역할을 구체적으로 (하위 페이지에서)**
   - ❌ "백엔드 개발 총괄"
   - ✅ "ERD 설계, Flask Blueprint 14개 구조 설계, API 문서 작성"

3. **모든 것을 쑤셔넣지 말기**
   - 돋보이는 것 위주로만
   - 목록 형식으로 깔끔하게

4. **전체 API 목록은 노션에서 제거**
   - ⚠️ **README에도 전체 API 문서는 없음** (노션에만 있던 내용)
   - 본인이 구현한 API만 명시
   - 팀 전체 규모 표현 제거

---

## 📌 참고: 각 프로젝트 내가 한 것 요약

### Coffee Shop (1차)
- Spring Entity/Service/Repository/Controller 구현
- React 공지사항 페이지 구현

### Bros (2차)
- ERD 설계, Flask Blueprint 구조 설계
- API 문서 작성, DB 연결
- JWT + OAuth 인증
- 게시물/피드/멘션 API 개발

### Smart Factory (3차)
- ERD 설계, 멀티 서버 아키텍처 설계
- Flask: MQTT 센서 수집, AI 서버 통신, WebSocket 실시간 알림
- Spring Boot: JWT 인증, WebSocket 채팅, Scheduler 자동 근태, 트랜잭션 급여 계산

---

**마지막 업데이트**: 2026년 1월 20일
